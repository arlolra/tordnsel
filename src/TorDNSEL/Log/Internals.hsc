{-# LANGUAGE ForeignFunctionInterface, TypeSynonymInstances,
             OverlappingInstances #-}

-----------------------------------------------------------------------------
-- |
-- Module      : TorDNSEL.Log.Internals
-- License     : Public domain (see LICENSE)
--
-- Maintainer  : tup.tuple@googlemail.com
-- Stability   : alpha
-- Portability : non-portable (concurrency, extended exceptions,
--                             type synonym instances, overlapping instances,
--                             foreign function interface)
--
-- /Internals/: should only be imported by the public module and tests.
--
-- Implements a logger thread and functions to log messages, reconfigure the
-- logger, and terminate the logger.
--
-----------------------------------------------------------------------------

-- #not-home
module TorDNSEL.Log.Internals where

import Prelude hiding (log)
import Control.Concurrent.Chan (Chan, newChan, writeChan, readChan)
import Control.Concurrent.MVar (MVar, newMVar, readMVar, swapMVar)
import qualified TorDNSEL.Compat.Exception as E
import Control.Monad (when, liftM2)
import Control.Monad.Fix (fix)
import Control.Monad.Trans (MonadIO, liftIO)
import Data.Bits ((.|.))
import qualified Data.ByteString.Char8 as B
import Data.List (foldl')
import Data.Time (UTCTime, getCurrentTime)
import Foreign.C (CString, CInt, withCString)
import System.IO
  (Handle, stdout, stderr, openFile, IOMode(AppendMode), hFlush, hClose)
import System.IO.Unsafe (unsafePerformIO)

import TorDNSEL.Control.Concurrent.Link
import TorDNSEL.Control.Concurrent.Util
import TorDNSEL.Util

#include <syslog.h>

-- | The logging configuration.
data LogConfig = LogConfig
  { minSeverity :: !Severity  -- ^ Minimum severity level to log
  , logTarget   :: !LogTarget -- ^ Where to send log messages
  , logEnabled  :: !Bool      -- ^ Is logging enabled?
  } deriving (Eq, Show)

-- | Where log messages should be sent.
data LogTarget = ToStdOut | ToStdErr | ToSysLog | ToFile FilePath
  deriving Eq

instance Show LogTarget where
  show ToStdOut    = "stdout"
  show ToStdErr    = "stderr"
  show ToSysLog    = "syslog"
  show (ToFile fp) = esc maxPathLen (B.pack fp) ""
    where maxPathLen = 256

-- | Open a handle associated with a given 'LogTarget' and pass it to an 'IO'
-- action, ensuring that the handle is closed or flushed as appropriate when the
-- action terminates. Exceptions generated by the action are re-thrown.
withLogTarget :: LogTarget -> (Maybe Handle -> IO a) -> IO a
withLogTarget ToStdOut io = E.bracket (return stdout) hFlush (io . Just)
withLogTarget ToStdErr io = E.bracket (return stderr) hFlush (io . Just)
withLogTarget ToSysLog io = io Nothing
withLogTarget (ToFile fp) io =
  E.bracket (openFile fp AppendMode) hClose (io . Just)

-- | An internal type for messages sent to the logger.
data LogMessage
  = Log UTCTime Severity ShowS                   -- ^ A log message
  | Reconfigure (LogConfig -> LogConfig) (IO ()) -- ^ Reconfigure the logger
  | Terminate ExitReason -- ^ Terminate the logger gracefully

-- | Logging severities.
data Severity = Debug | Info | Notice | Warn | Error
  deriving (Eq, Ord, Show)

-- | The logger's 'ThreadId' and channel, if it is running.
logger :: MVar (Maybe (ThreadId, Chan LogMessage))
{-# NOINLINE logger #-}
logger = unsafePerformIO $ newMVar Nothing

-- | If the logger is running, invoke an 'IO' action with its 'ThreadId' and
-- channel.
withLogger :: (ThreadId -> Chan LogMessage -> IO ()) -> IO ()
withLogger io = readMVar logger >>= flip whenJust (uncurry io)

-- | A handle to the logger thread.
newtype Logger = Logger ThreadId

instance Thread Logger where
  threadId (Logger tid) = tid

-- | Start the global logger with an initial 'LogConfig', returning a handle to
-- it. Link the logger to the calling thread. If the logger exits before fully
-- starting, throw its exit signal in the calling thread.
startLogger :: LogConfig -> IO Logger
startLogger initConf =
  fmap Logger . startLink $ \initSignal -> do
    curLogger@(_,logChan) <- liftM2 (,) myThreadId newChan
    setTrapExit . const $ writeChan logChan . Terminate
    E.bracket_ (swapMVar logger $ Just curLogger) (swapMVar logger Nothing) $
      flip fix (initConf, initSignal) $ \resetLogger (conf, signal) ->
        (resetLogger =<<) . withLogTarget (logTarget conf) $ \mbHandle -> do
          log Notice "Opened log to " (logTarget conf) '.'
          signal
          fix $ \nextMsg -> do
            msg <- readChan logChan
            case msg of
              Log time severity logMsg -> do
                when (logEnabled conf && severity >= minSeverity conf) $
                  case mbHandle of
                    Just h -> do
                      hCat h (showUTCTime time) " [" severity "] " logMsg '\n'
                      hFlush h
                    Nothing ->
                      sysLog severity (logMsg "")
                nextMsg
              Reconfigure reconf newSignal -> do
                let newConf = reconf conf
                when (conf /= newConf) $
                  log Info "Reconfigured logger."
                return (reconf conf, newSignal)
              Terminate reason -> exit reason

-- | Implements the variable parameter support for 'log'.
class LogType r where
  log' :: CatArg a => ShowS -> Severity -> a -> r

instance MonadIO m => LogType (m a) where
  log' str sev arg = liftIO $ do
    now <- getCurrentTime
    mbLogger <- readMVar logger
    case mbLogger of
      Just (_,logChan) ->
        writeChan logChan (Log now sev (cat' str arg))
      Nothing
        | sev >= Notice -> do
            hCat stdout (showUTCTime now) " [" sev "] " str arg '\n'
            hFlush stdout
        | otherwise -> return ()
    return undefined -- to omit type annotations in do blocks

instance LogType (Severity, ShowS) where
  log' str sev arg = (sev, cat' str arg)

instance (CatArg a, LogType r) => LogType (a -> r) where
  log' str sev arg = log' (cat' str arg) sev

-- | Log a message asynchronously.
log :: (CatArg a, LogType r) => Severity -> a -> r
log = log' id

-- | Reconfigure the logger synchronously with the given function. If the logger
-- exits abnormally before reconfiguring itself, throw its exit signal in the
-- calling thread.
reconfigureLogger :: (LogConfig -> LogConfig) -> IO ()
reconfigureLogger reconf =
  withLogger $ \tid logChan ->
    sendSyncMessage (writeChan logChan . Reconfigure reconf) tid

-- | Terminate the logger gracefully: process any pending messages, flush the
-- log handle, and close the handle when logging to a file. The optional
-- parameter specifies the amount of time in microseconds to wait for the thread
-- to terminate. If the thread hasn't terminated by the timeout, an uncatchable
-- exit signal will be sent.
terminateLogger :: Maybe Int -> IO ()
terminateLogger mbWait =
  withLogger $ \tid logChan ->
    terminateThread mbWait tid (writeChan logChan $ Terminate Nothing)

--------------------------------------------------------------------------------
-- System logger

-- | Options to pass to syslog(3)'s openlog().
data SysLogOptions = SysLogOptions
  { noDelay         -- ^ Open the connection to the logger immediately.
  , logPid :: !Bool -- ^ Log the PID with each message.
  }

-- | The facility to which log messages should be assigned.
data SysLogFacility = Daemon -- ^ System daemons.

-- | Open a connection to the system logger using the given process identifier,
-- options, and facility.
openSystemLogger :: String -> SysLogOptions -> SysLogFacility -> IO ()
openSystemLogger identifier options facility =
  withCString identifier $ \c_identifier ->
    c_openlog c_identifier c_options c_facility
 where
   c_options = foldl' (.|.) 0
    [ x | (flag,x) <- [(noDelay, #{const LOG_NDELAY})
                      ,(logPid,  #{const LOG_PID})]
        , flag options ]
   c_facility = case facility of
     Daemon -> #{const LOG_DAEMON}

foreign import ccall unsafe "syslog.h openlog"
  c_openlog :: CString -> CInt -> CInt -> IO ()

-- | Close the connection to the system logger.
closeSystemLogger :: IO ()
closeSystemLogger = c_closelog

foreign import ccall unsafe "syslog.h closelog"
  c_closelog :: IO ()

-- | Send a message of the given 'Severity' to the system logger.
sysLog :: Severity -> String -> IO ()
sysLog severity message =
  withCString "%s" $ \c_format ->
    withCString message $ \c_message ->
      c_syslog c_severity c_format c_message
  where
    c_severity = case severity of
      Error  -> #{const LOG_ERR}
      Warn   -> #{const LOG_WARNING}
      Notice -> #{const LOG_NOTICE}
      Info   -> #{const LOG_INFO}
      Debug  -> #{const LOG_DEBUG}

foreign import ccall unsafe "syslog.h syslog"
  c_syslog :: CInt -> CString -> CString -> IO ()
