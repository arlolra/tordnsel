-----------------------------------------------------------------------------
-- |
-- Module      : TorDNSEL.Log.Internals
-- Copyright   : (c) tup 2007
-- License     : Public domain (see LICENSE)
--
-- Maintainer  : tup.tuple@googlemail.com
-- Stability   : alpha
-- Portability : non-portable (concurrency, extended exceptions)
--
-- /Internals/: should only be imported by the public module and tests.
--
-- Implements a logger thread and functions to log messages, reconfigure the
-- logger, and terminate the logger.
--
-----------------------------------------------------------------------------

-- #not-home
module TorDNSEL.Log.Internals where

import Prelude hiding (log)
import Control.Concurrent.Chan (Chan, newChan, writeChan, readChan)
import Control.Concurrent.MVar
  (MVar, newEmptyMVar, newMVar, takeMVar, putMVar, withMVar, readMVar, swapMVar)
import qualified Control.Exception as E
import Control.Monad (when, liftM2)
import Control.Monad.Fix (fix)
import Data.Maybe (isJust)
import Data.Time (UTCTime, getCurrentTime)
import System.IO
  (Handle, stdout, stderr, openFile, IOMode(AppendMode), hFlush, hClose)
import System.IO.Unsafe (unsafePerformIO)
import Text.Printf (hPrintf)

import TorDNSEL.Control.Concurrent.Link
import TorDNSEL.System.Timeout
import TorDNSEL.Util

-- | The logging configuration.
data LogConfig = LogConfig
  { minSeverity :: !Severity  -- ^ Minimum severity level to log
  , logTarget   :: !LogTarget -- ^ Where to send log messages
  , logEnabled  :: !Bool      -- ^ Is logging enabled?
  } deriving Show

-- | Where log messages should be sent.
data LogTarget = ToStdOut | ToStdErr | ToFile FilePath

instance Show LogTarget where
  show ToStdErr    = "stderr"
  show ToStdOut    = "stdout"
  show (ToFile fp) = show fp

-- | Open a handle associated with a given 'LogTarget' and pass it to an 'IO'
-- action, ensuring that the handle is closed or flushed as appropriate when the
-- action terminates. Exceptions generated by the action are re-thrown.
withLogTarget :: LogTarget -> (Handle -> IO a) -> IO a
withLogTarget ToStdOut    = E.bracket (return stdout) hFlush
withLogTarget ToStdErr    = E.bracket (return stderr) hFlush
withLogTarget (ToFile fp) = E.bracket (openFile fp AppendMode) hClose

-- | An internal type for messages sent to the logger.
data LogMessage
  = Log UTCTime Severity String                  -- ^ A log message
  | Reconfigure (LogConfig -> LogConfig) (IO ()) -- ^ Reconfigure the logger
  | Terminate ExitReason -- ^ Terminate the logger gracefully

-- | Logging severities.
data Severity = Debug | Info | Notice | Warn | Error
  deriving (Eq, Ord, Show)

-- | The logger's 'ThreadId' and channel, if it is running.
logger :: MVar (Maybe (ThreadId, Chan LogMessage))
{-# NOINLINE logger #-}
logger = unsafePerformIO $ newMVar Nothing

-- | If the logger is running, invoke an 'IO' action with its 'ThreadId' and
-- channel.
withLogger :: (ThreadId -> Chan LogMessage -> IO ()) -> IO ()
withLogger io = readMVar logger >>= flip whenJust (uncurry io)

-- | Start the global logger with an initial 'LogConfig', returning its
-- 'ThreadId'. Link the logger to the calling thread. If the logger exits before
-- fully starting, throw its exit signal in the calling thread.
startLogger :: LogConfig -> IO ThreadId
startLogger config = do
  err <- newEmptyMVar
  tid <- forkLinkIO $ do
    curLogger@(loggerId,logChan) <- liftM2 (,) myThreadId newChan
    setTrapExit . const $ writeChan logChan . Terminate
    E.bracket_ (swapMVar logger $ Just curLogger) (swapMVar logger Nothing) $
      flip fix (config, putMVar err Nothing) $ \resetLogger (conf, signal) -> do
        (resetLogger =<<) . withLogTarget (logTarget conf) $ \handle -> do
          signal
          fix $ \nextMsg -> do
            msg <- readChan logChan
            case msg of
              Log time severity text -> do
                when (logEnabled conf && severity >= minSeverity conf) $
                  hPrintf handle "%s [%s] %s\n" (showUTCTime time)
                                                (show severity) text
                nextMsg
              Reconfigure reconf signal -> return (reconf conf, signal)
              Terminate reason -> exit reason
  mon <- monitorThread tid (putMVar err)
  takeMVar err >>= maybe (demonitorThread mon >> return tid) E.throwIO

-- XXX log should take a variable number of arguments
-- | Log a message asynchronously.
log :: Severity -> String -> IO ()
log severity msg = do
  now <- getCurrentTime
  withLogger $ \_ logChan ->
    writeChan logChan $ Log now severity msg

-- | Reconfigure the logger synchronously with the given function. If the logger
-- exits abnormally before reconfiguring itself, throw its exit signal in the
-- calling thread.
reconfigureLogger :: (LogConfig -> LogConfig) -> IO ()
reconfigureLogger reconf =
  withLogger $ \tid logChan -> do
    err <- newEmptyMVar
    mon <- monitorThread tid (putMVar err)
    writeChan logChan . Reconfigure reconf $ putMVar err Nothing
    takeMVar err >>= maybe (demonitorThread mon) E.throwIO

-- | Terminate the logger gracefully: process any pending messages, flush the
-- log handle, and close the handle when logging to a file. The optional
-- parameter specifies the amount of time in microseconds to wait for the thread
-- to terminate. If the thread hasn't terminated by the timeout, an uncatchable
-- exit signal will be sent.
terminateLogger :: Maybe Int -> IO ()
terminateLogger = withLogger . terminateThread (Terminate Nothing)

-- | Terminate the thread @tid@ by sending @termMsg@ to @chan@. @mbWait@
-- specifies the amount of time in microseconds to wait for the thread to
-- terminate. If the thread hasn't terminated by the timeout, an uncatchable
-- exit signal will be sent.
terminateThread :: a -> Maybe Int -> ThreadId -> Chan a -> IO ()
terminateThread termMsg mbWait tid chan = do
  dead <- newEmptyMVar
  mon <- monitorThread tid (const $ putMVar dead ())
  writeChan chan termMsg
  case mbWait of
    Nothing -> takeMVar dead
    Just wait -> do
      r <- timeout wait (takeMVar dead)
      if isJust r then return () else do
      killThread tid
      takeMVar dead
